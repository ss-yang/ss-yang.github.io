<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android-用Intent在活动之间传递数据的三种方法]]></title>
    <url>%2F2017%2F05%2F14%2FAndroid-%E7%94%A8Intent%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Intent intent n. 意图；目的； Intent最常见的用法是启动活动、服务等，实现Activity间跳转。 那么问题来了，在跳转的时候，怎样给下一个Activity捎一些数据呢？ 三种方法 putExtra serializable parcelable - putExtra()Intent类提供了putExtra()方法，可以向intent对象添加一些常见类型的附加数据。只要在startActivity之前调用即可。 intent.putExtra(&quot;string_data&quot;,&quot;hello&quot;); 然后在另一边用getStringExtra()接收： getIntent.getStringExtra(&quot;string_data&quot;); 这种方法很简单，简单到只能传基本数据类型的数据，要传自定义的对象就无能为力了。 - serializable这是一个接口，serializable即序列化，能将对象转化成可以直接传输的数据，可以理解为将对象简单粗暴的用一串二进制表示，然后就可传输了。 用法非常简单，只要在要传输的类定义里面实现Serializable接口。 public class Article implements Serializable{ …… } putExtra()跟上面的方法一样，只是把put的对象换成自定义的对象了 intent.putExtra(&quot;article&quot;,article); 再到下一个Activity取出传过来的序列化对象，就完成了。 article = (Article) getIntent.getSerializbleExtra(&quot;article&quot;); 是不是超级简单粗暴！ 但由于是直接传递整个对象，不可避免的会降低效率，尤其是传递体量较大的对象时。这个时候推荐用parcelable方法来实现。 - parcelableparcelable即包裹化，原理是先将对象拆开，再把真正有用的数据打包带走。 相比序列化的方法，parcelable实现了精准传递，很多时候我只需要对象的某些数据，并不是所有数据。也因为这种机制，这种方式实现起来较为复杂（拆开和打包需要自己动手）。 1. 实现接口public class Article implements Parcelable{ private int id; private String title; private String author; private String content; private String time; private String last_time; 2. 先看看源码（Parcelable.java）public interface Parcelable { public static final int PARCELABLE_WRITE_RETURN_VALUE = 0x0001; public static final int PARCELABLE_ELIDE_DUPLICATES = 0x0002; public static final int CONTENTS_FILE_DESCRIPTOR = 0x0001; public int describeContents(); public void writeToParcel(Parcel dest, int flags); public interface Creator&lt;T&gt; { public T createFromParcel(Parcel source); public T[] newArray(int size); } public interface ClassLoaderCreator&lt;T&gt; extends Creator&lt;T&gt; { public T createFromParcel(Parcel source, ClassLoader loader); } } 这里只需要重写describeContents、writeToParcel和Creator 3. 重写describeContents通常，这里什么都不用做，直接返回0. @Override public int describeContents(){ return 0; } 4. 重写writeToParcel通过writeXXX()方法写出对象的属性。XXX可以是各种受支持的数据类型。 @Override public void writeToParcel(Parcel dest, int flag){ dest.writeInt(id); dest.writeString(title); dest.writeString(author); dest.writeString(content); dest.writeString(time); dest.writeString(last_time); } 5. Creator从源码可以看出，public interface Creator 是一个泛型接口，里面需要重写两个方法。 createFromParcel方法将打包的数据读取，重新封装成泛型指示的对象。 newArray方法返回一个对象数组。 public static final Parcelable.Creator&lt;Article&gt; CREATOR = new Creator&lt;Article&gt;(){ @Override public Article createFromParcel(Parcel source){ Article article = new Article(); article.setId(source.readInt()); article.setTitle(source.readString()); article.setAuthor(source.readString()); article.setContent(source.readString()); article.setTime(source.readString()); article.setLast_time(source.readString()); return article; } @Override public Article[] newArray(int size){ return new Article[size]; } }; 注意这里读取数据的顺序应该和上一步写数据的顺序一样。 6. 在下一个活动中接收数据接受数据和前两种方法相差无几。用的是getParcelableExtra()方法。 总结三种传数据的方法的思路都是一样的，都是A把数据put给intent，B从intent里面读取。不同的是实现的细节，第一种只能put一些基本数据类型，后两种方法进行了扩展，可以支持自定义类型。其中serializable直接将序列化后的对象传递，parcelable将对象的属性写入包裹，再从包裹重建对象，比前者效率高，但实现起来比前者复杂。 附：Intent putExtra支持的所有类型 Intent putExtra(String name, String[] value) Intent putExtra(String name, long value) Intent putExtra(String name, boolean value) Intent putExtra(String name, double value) Intent putExtra(String name, Parcelable[] value) Intent putExtra(String name, char value) Intent putExtra(String name, int[] value) Intent putExtra(String name, int value) Intent putExtra(String name, double[] value) Intent putExtra(String name, short value) Intent putExtra(String name, long[] value) Intent putExtra(String name, boolean[] value) Intent putExtra(String name, short[] value) Intent putExtra(String name, String value) Intent putExtra(String name, float[] value) Intent putExtra(String name, Bundle value) Intent putExtra(String name, byte[] value) Intent putExtra(String name, CharSequence value) Intent putExtra(String name, char[] value) Intent putExtra(String name, byte value) Intent putExtras(Intent src) Intent putExtras(Bundle extras) Intent putExtra(String name, Serializable value) Intent putExtra(String name, Parcelable value)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-RecyclerView通过addOnItemTouchListener处理onClick点击事件]]></title>
    <url>%2F2017%2F05%2F13%2FAndroid-RecyclerView%E9%80%9A%E8%BF%87addOnItemTouchListener%E5%A4%84%E7%90%86onClick%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[原因现在android开发中ListView效果越来越多的用RecyclerView来实现了，RecyclerView相比前者有非常多的优点，还可以轻松实现瀑布流布局、扇形列表等。。。 但是！！ 用的时候发现RecyclerView没有提供OnItemClick()，网上查的大多数博客都采用在Adapter里面自己定义接口的方法来模拟ListView的点击事件,有些还模拟了长按、短按等功能。 解决这样模拟终究不是好方法，官方虽然没有提供click方法，但是提供了更为强大的addOnItemTouchListener接口，结合GestureDetectorCompat手势检测可以方便的实现很多功能。 1. 为recycleView添加监听器recyclerView.addOnItemTouchListener(new RecyclerView.OnItemTouchListener() { @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) { return false; } @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) { } @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) { } }); 其中： onInterceptTouchEvent：拦截触摸事件 onTouchEvent：处理触摸事件 onRequestDisallowInterceptTouchEvent：通常用于请求ViewPager不要拦截该控件上的触摸事件。 很明显，现在需要拦截触摸事件，拦截下来才能实现功能 2. 既然只要处理onInterceptTouchEvent，那就可以删掉另外两个方法。3. 声明一个GestureDetector，传入GestureDetector.SimpleOnGestureListener实例化。SimpleOnGestureListener提供的onSingleTapUp和onLongPress，正是想要的功能！！ GestureDetector gestureDetector; gestureDetector = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener(){ @Override public boolean onSingleTapUp(MotionEvent e){ View childView = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (childView != null) { int position = recyclerView.getChildLayoutPosition(childView); Toast.makeText(getApplication(), &quot;single click:&quot; + position, Toast.LENGTH_SHORT).show(); return true; } return super.onSingleTapUp(e); } @Override public void onLongPress(MotionEvent e) { super.onLongPress(e); View childView = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (childView != null) { int position = recyclerView.getChildLayoutPosition(childView); Toast.makeText(getApplication(), &quot;long click:&quot; + position, Toast.LENGTH_SHORT).show(); } } }); 这里不能直接声明为SimpleOnGestureListener，因为要用到父类的onTouchEvent 4. 最后，在第1步的onInterceptTouchEvent里面加上一个简单的判断就可以了。@Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) { if (gestureDetector.onTouchEvent(e)) { return true; } return false; } 5. 完成！ 进阶：更完善的解决方法 - 封装成接口，方便重用 先说结果，封装成接口后，调用代码从上面一大堆变成短短几行，清晰明了。 recyclerView.addOnItemTouchListener(new RecyclerItemClickListener(getBaseContext(), recyclerView, new RecyclerItemClickListener.OnItemClickListener() { @Override public void onItemClick(View view, int position) { //轻触... } @Override public void onItemLongClick(View view, int position) { //长按... } })); 只需要写回调函数里的逻辑即可。 怎么封装类呢？ 1. 新建一个类 RecyclerItemClickListener，包含一个Item点击监听器和一个手势检测：public class RecyclerItemClickListener implements RecyclerView.OnItemTouchListener { private OnItemClickListener mListener; private GestureDetector gestureDetector; } 2. 定义一个OnItemClickListener接口，里面包含两个回调函数public interface OnItemClickListener { void onItemClick(View view, int position); void onItemLongClick(View view, int position); } 3. 构造函数构造函数需要接收Context、RecyclerView、OnItemClickListener三个参数. Context 上下文传递 RecyclerView 接口实现的功能跟RecyclerView密切相关，可以通过这个参数获取position OnItemClickListener 可以理解为回调函数的通道 public RecyclerItemClickListener(Context context, final RecyclerView recyclerView, OnItemClickListener listener) { mListener = listener; gestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() { @Override public boolean onSingleTapUp(MotionEvent e) { View child = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (child != null &amp;&amp; mListener != null) { mListener.onItemClick(child, recyclerView.getChildAdapterPosition(child)); } return true; } @Override public void onLongPress(MotionEvent e) { View child = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (child != null &amp;&amp; mListener != null) { mListener.onItemLongClick(child, recyclerView.getChildAdapterPosition(child)); } } }); } 4. 重写onInterceptTouchEvent()@Override public boolean onInterceptTouchEvent(RecyclerView view, MotionEvent e) { View childView = view.findChildViewUnder(e.getX(), e.getY()); if (childView != null &amp;&amp; mListener != null &amp;&amp; gestureDetector.onTouchEvent(e)) { mListener.onItemClick(childView, view.getChildAdapterPosition(childView)); return true; } return false; } 5. 完成 参考资料: android-RecyclerView onClick-Stack Overflow]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop - CentOS7虚拟机中搭建Hadoop集群（一）]]></title>
    <url>%2F2017%2F05%2F11%2FHadoop-CentOS7%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E6%90%AD%E5%BB%BAHadoop%E9%9B%86%E7%BE%A4%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[环境： centos 64 1611 hadoop2.7.3a jdk1.8.0_131 1. linux安装1. 安装虚拟机软件（VirtualBox和VMWare都可以）2. 新建centos虚拟机，挂载centos7镜像3. 选择最小安装+开发工具 2. 安装Hadoop前的准备安装hadoop可以用root用户也可以新建一个用户,建议新建一个用户。 1. 把ip地址改为静态ip，以免以后要改来改去修改网络连接配置文件 vi /etc/sysconfig/network-scripts/ifcfg-eth0 ... BOOTPRORO=static IPADDR=ip地址 ... 2. 设置DNSvi /etc/resolv.conf nameserver 114.114.114.114 3. 测试一下网络是不是正常4. 修改主机名vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=yourname :wq 5. 关防火墙#查看防火墙状态 service iptables status #关闭防火墙 service iptables stop #查看防火墙开机启动状态 chkconfig iptables --list #关闭防火墙开机启动 chkconfig iptables off 6. 配置ssh免密码登陆在每台服务器上生成公钥密钥，再将公钥合并到master的authorized_keys文件上。 注意！！master和slave都要用相同的user和group (这里为hadoop) centos默认关闭ssh免密码登陆，需要到/etc/ssh/sshd_config文件把下面两行取消注释： RSAAuthentication yes PubkeyAuthentication yes 然后，在master和每个slave上分别生成密钥： ssh-keygen -t rsa 将slave的公钥合并到authorized_keys文件，在master中进入/home/hadoop/.ssh目录，用重定向符号合并： 123cat id_rsa.pub&gt;&gt; authorized_keysssh hadoop@192.168.0.183 cat ~/.ssh/id_rsa.pub&gt;&gt; authorized_keysssh hadoop@192.168.0.184 cat ~/.ssh/id_rsa.pub&gt;&gt; authorized_keys 合并完成后，再将master的authorized_keys和known_hosts文件通过scp命令复制到每个slave的.ssh目录里，至此，每台slave和master都互有公钥。 12scp /home/hadoop/.ssh/known_hosts hadoop@192.168.5.134:/home/hadoop/.ssh/scp /home/hadoop/.ssh/authorized_keys hadoop@192.168.5.134:/home/hadoop/.ssh/ 回master测试，已经可以无需密码登陆其他slave了(第一次需要密码)，如果失败，看6。 [hadoop@yang .ssh]$ ssh hadoop@192.168.5.132 Last login: Thu May 11 20:51:47 2017 from 192.168.5.133 [hadoop@yang01 ~]$ 如果免密码登陆失败，到slave把authorized_keys的权限改成“-rw——-”就可以了： chmod 600 authorized_keys [hadoop@yang01 .ssh]$ ll -rw-------. 1 hadoop hadoop 1183 5月 11 20:18 authorized_keys 7. 安装jdk 到官网下载最新jkd版本的rpm包 rpm -ivh jdk**.rpm 配置环境变量 java -version 测试]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - ToolBar searchView 实现搜索框]]></title>
    <url>%2F2017%2F05%2F02%2FAndroid-ToolBar-searchView-%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E6%A1%86%2F</url>
    <content type="text"><![CDATA[在ToolBar上可以很方便的用widget.SearchView实现搜索功能。一般情况下，SearchView通常有两种实现方案： 在当前Activity处理搜索逻辑 首先在menu中新增item 12345&lt;item android:id=&quot;@+id/toolbar_search&quot; android:title=&quot;Search&quot; app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot; app:showAsAction=&quot;always&quot;/&gt; onCreateOptionsMenu中增加如下代码： 1234567891011121314151617181920212223 public boolean onCreateOptionsMenu(Menu menu)&#123; getMenuInflater().inflate(R.menu.tool_bar,menu); //Toolbar的搜索框 MenuItem searchItem = menu.findItem(R.id.toolbar_search); SearchView searchView = null; if (searchItem != null) &#123; searchView = (SearchView) searchItem.getActionView(); &#125; searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() &#123; @Override public boolean onQueryTextSubmit(String query) &#123; //处理搜索结果 Toast.makeText(MainActivity.this,&quot;搜索: &quot; + query,Toast.LENGTH_LONG).show(); return false; &#125; @Override public boolean onQueryTextChange(String s) &#123; return false; &#125; &#125;); return true;&#125; 在新Activity处理搜索逻辑 在menu中新增item（同上） 在onCreateOptionsMenu中增加如下代码： 123456789101112131415public boolean onCreateOptionsMenu(Menu menu) &#123; MenuInflater menuInflater = getMenuInflater(); menuInflater.inflate(R.menu.dashboard, menu); MenuItem searchItem = menu.findItem(R.id.action_search); SearchManager searchManager = (SearchManager) MainActivity.this.getSystemService(Context.SEARCH_SERVICE); SearchView searchView = null; if (searchItem != null) &#123; searchView = (SearchView) searchItem.getActionView(); &#125; if (searchView != null) &#123; searchView.setSearchableInfo(searchManager.getSearchableInfo(MainActivity.this.getComponentName())); &#125; return super.onCreateOptionsMenu(menu);&#125; 在res/xml/下新建searchable.xml文件，内容如下： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;searchable xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:hint=&quot;@string/search_hint&quot;android:label=&quot;@string/app_name&quot; /&gt; 新建处理搜索结果的activity：SearchResultsActivity AndroidManifest文件添加下面的代码： 1234567891011121314&lt;activity android:name=&quot;com.example.SearchResultsActivity&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEARCH&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.app.searchable&quot; android:resource=&quot;@xml/searchable&quot; /&gt;&lt;/activity&gt; 在SearchResultsActivity里面处理搜索结果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 创建应用程序快捷启动器的方法]]></title>
    <url>%2F2017%2F04%2F30%2Fcentos7-%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原因在linux下装好了android studio, 却发现只能在安装目录下通过terminal执行studio.sh来运行，这样明显很不方便。但作为一个linux新司机，并不知道怎么办。桌面右建-&gt;新建启动器，centos里根本没有这一项。后来因为某些原因需要重装中国版的firefox，官方安装包下载下来后，也是直接解压使用的(需要从terminal启动）。同一个问题遇到两次，不能忍。 解决方法查资料后得知，centos 的程序图表都在/usr/share/applications/文件夹下，里面都是.desktop文件。于是问题迎刃而解。 新建一个android-studio.desktop文件，内容如下： [Desktop Entry] Encoding=UTF-8 Name=Android Studio 2.3 Comment=Android Studio Comment[zh_CN]=安卓开发 Exec=/usr/local/bin/android-studio #运行路径 Icon=/opt/android-studio/bin/studio.png #图标 Categories=Application;Development;Android; #分类：这个将在应用的编程分类中 Actions=NewWindow;NewPrivateWindow; Type=Application Terminal=0 #是否命令行形式 至此，应用程序菜单里面就有了刚刚添加的启动器了，也可以将desktop文件复制到桌面。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>